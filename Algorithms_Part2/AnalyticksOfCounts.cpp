// На входе программы имеем n - количество чисел x1 ... xn;
// число e - количество равенств xi = xj;
// d - количество неравенств xp != xq;
// Далее следует e пар чисел с номерами элементов, задающих равенства
// и d пар чисел с номерами элементов, задающих неравенства;

// Выход: 0 или 1 ;
// Можно ли подобрать целые значения переменных,
// чтобы они удовлетворяли заданной системе равенств и неравенств?
// Нет ли противоречий между парами e и d?

#include <iostream>
#include <vector>

// Определяем идентификатор множества
size_t Find(size_t i, std::vector<size_t> *parent){
    if (i != (*parent).at(i))
        // используем эвристический подход
        // для автоматического сжатия путей поиска
        (*parent).at(i) = Find((*parent).at(i), parent);
    return (*parent).at(i);
}

// Операция обьединения множеств
// Всегда подвешиваем source к dest
void Union(size_t i, size_t j, std::vector<size_t> *parent){
    // Находим родителей элементов
    size_t i_id = Find(i, parent);
    size_t j_id = Find(j, parent);
    if (i_id != j_id)
        (*parent).at((*parent).at(j)) = (*parent).at(i);
}

int main(){
    size_t n, e, d;
    std::cin >> n >> e >> d;

//    // проверка входных краевых условий
//    if ( n == 1){
//        if (d == 1)
//            // Один единственный элемент не может быть не равен сам себе
//            std::cout << 0 << std::endl;
//        else
//            std::cout << 1 << std::endl;
//        return 0;
//    }

    // вектор вершин деревьев(ID множества - это корень дерева);
    std::vector<size_t> parent;
    for (size_t i = 0; i < n; i++)
        // Автоматически создаем множества для каждого элемента;
        parent.push_back(i); // parent[i] = i;

        // объединяем множества с равными элементами
    for (size_t x = 0; x < e; x++){
        size_t i, j;
        std::cin >> i >> j;
        // Нумерация массива с 0;
        Union(i-1, j-1, &parent);
    }

    // проверяем, что неравные элементы находятся в разных множествах;
    for (size_t i = 0; i < d; i++){
        size_t a, b;
        std::cin >> a >> b;
        size_t a_id = Find(a-1, &parent);
        size_t b_id = Find(b-1, &parent);
        if (a_id == b_id){
            // Если родители совпадают, то элементы равны,
            // что приводит к противоречию
            std::cout << 0 << std::endl;
            return 0;
        }
    }


    // Если противоречий найдено не было, то условия удовлетворены
    std::cout << 1 << std::endl;

    return 0;
}
