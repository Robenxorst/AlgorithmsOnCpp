// Данныая программа получает на вход список сетевых покетов
// (время получения пакета и время обработки пакета), для которых
// нужно рассчитать время начала обработки их компьютером.
// При этом обрабатывать в один момент времени можно лишь один пакет,
// а другие могут находиться в буфере(обработка идет из буфера).
// Пакет прилетевший в уже занятый буфер отработан не будет.
// (буфер может хранить определенное число пакетов);

// Пример:
//0 0
//0 0
//0 0
//1 0
//1 0
//1 1
//1 2
//1 3

//Выход: 0 0 0 1 1 1 2 -1

// Первые два числа:
// 1) вместимость буфера(сколько пакетов там может лежать);
// 2) Количество пакетов на входе;

# include <iostream>
# include <vector>
# include <queue>

int main(){
    std::queue <int> last_time; // используем очередь
    // для хранения времени конца обработки предыдущего пакета

    int buf; // Размерность буфера(в очереди может быть толко buf чисел);
    int pockets; // Количество пакетов на входе;
    std::cin >> buf;
    std::cin >> pockets;

    if (pockets == 0)
        return 0;

    int t_0; // время начала обработки покета;

    // первый элемент всегда будет обработан!
    int first_a;
    int first_d;
    std::cin >> first_a;
    std::cin >> first_d;
    std::cout << first_a << std::endl;
    last_time.push(first_a + first_d); // помещаем в очередь
    // конец обработки первого элемента

    for (int i = 1; i < pockets; i++){
        int t_a; // время прибытия пакета;
        int t_d; // время, затрачиваемое на обработку пакета;
        std::cin >> t_a;
        std::cin >> t_d;

        if (t_a < last_time.front()){
            if (last_time.size() >= buf)
                // пакет не попадает в очередь и не будет обработан
                std::cout << -1 << std::endl;
            else{// в буфере есть свободное место;
                t_0 = last_time.back();
                // время начала обработки данного покета - это конец обработки последнего положенного в очередь;
                std::cout << t_0 << std::endl;
                last_time.push(t_0 + t_d);
            }
        }
        else if (t_a >= last_time.front()){ // пакет попадает в очередь
            last_time.pop(); // передовой элемент очереди был обработан
            t_0 = std::max(last_time.back(), t_a);
            // на выход даем либо время конца обработки последнего элемента,
            // добавленного в очередь, либо время t_a;
            std::cout << t_0 << std::endl;
            // Добавляем в очередь новое время окончания
            last_time.push(t_0 + t_d);
        }
    }

    return 0;
}